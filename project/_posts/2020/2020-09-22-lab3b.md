---
layout: talk
title: "Lab 3(b): Creating Static Analysis Tests"
tag: project
categories: []
kind: Project
series: project
speaker:
authors:
pdf:
image:
talkURL:
eventURL:
event:
date: 2020-09-22 10:01
admin: true
redirect_from:
- /lab/3b
---

Before getting started with your static analysis definition, you set up a test suite for static analysis. Develop the test suite in tandem with the development of your static analysis. The test suite consists of positive and negative test cases. We will not grade this test suite, but you should develop one to get confidence in the quality of your static analysis. When you are asking for help from the course staff, we will first ask what tests you have written to demonstrate the problem.

Note: This notes uses MiniJava examples, the old project language for the course. They should be replace with ChocoPy exampes, but the concepts are the same.

### Objectives

In the `chocopy.types.test` project, develop a test suite for static analysis. The test suite should provide

1. Test cases for types
2. Test cases for name resolution
3. Test cases for errors  



### Testing Type Constraints

See the example tests in the [WebLab homework assignments](https://weblab.tudelft.nl/cs4200/2020-2021/assignment/51094/view) for Week 3.

### Testing Reference Resolution

In test cases for reference resolution,
 you write syntactically correct programs and
 mark names at definition and use sites with inner square bracket blocks.
You can then relate the use site with the definition site in a `resolve x to y` clause,
  using numbers to refer to the inner blocks.
For example, the following two test cases require to resolve the type `Foo` to the name in the definition of class `Foo`:

```
module resolution

language minijava
start symbol Program

test forward class name resolution [[
  class Main {
    public static void main(String[] args) {
      System.out.println(1);
    }
  }

  class Foobar {
    [[Foo]] x;
  }

  class [[Foo]] {}
]] resolve #1 to #2

test backward class name resolution [[
  class Main {
    public static void main(String[] args) {
      System.out.println(1);
    }
  }

  class [[Foo]] {}

  class Foobar {
    [[Foo]] x;
  }
]] resolve #2 to #1
```

After copying this into an SPT file Spoofax will add the error *"Reference resolution failed"* and *"No constraint generation rule for ..."*. This is expected, since your project is missing an implementation for reference resolution (this is part of the next lab).

You can use _fixtures_ to avoid repeating parts in similar test cases. See the [SPT documentation](http://www.metaborg.org/en/latest/source/langdev/meta/lang/spt/test-suites.html#test-fixtures) for details.

You should come up with test cases for the resolution of class names, field names, parameter names, and variable names.
Start with simple test cases, but keep in mind that coverage is the main criterion for your grade.
It is important to think about
 forward and backward references,
 and resolution in the presence of homonyms.

Make sure that there are no errors in tests with a `resolve x to y` clause, these tests are invalid when there are errors.
{: .notice .notice-warning}

Do not use start symbols other than `Program`.
{: .notice .notice-warning}


### Testing Error Checking

In test cases for error checking, you need to specify the number of errors, warnings, or notes in a
test case in `errors`, `warnings`, or `notes` clauses.  For example, the following test cases
specify a correct MiniJava program, a program with two errors which are reported on the name of a
duplicate class `Foo`, and another program with an error which is reported on the name of an unknown
class `Bar`:

```
module resolution

language minijava
start symbol Program

test correct program [[
  class Main {
    public static void main(String[] args) {
      System.out.println(1);
    }
  }

  class Foo {}

  class Foobar {
    Foo x;
  }
]] 0 errors

test error on duplicate class [[
  class Main {
    public static void main(String[] args) {
      System.out.println(1);
    }
  }

  class Foo {}

  class Foo {}
]] >= 1 errors

test error on unknown class [[
  class Main {
    public static void main(String[] args) {
      System.out.println(1);
    }
  }

  class Foo {
    Bar x;
  }
]] >= 1 errors
```

You can start with test cases for duplicate and missing definitions.  Similar to your syntax test
cases, you can pair up positive (`0 errors`) and negative test cases.  For duplicate definitions, we
expect errors on the definitions with the same name.

The number of errors can be hard to predict, because errors sometimes cascade. Therefore, if you
expect any errors, you should use the `>= 1 errors` expectation, even if you expect a specific
number of errors. For example, this expectation was used in the duplicate class test, even though we
would expect exactly two errors.
{: .notice .notice-warning}

Next, you should develop test cases for fields and variables which hide fields, and main class
instantiation, subclassing, referencing.  Again, you should keep in mind that coverage is the main
criterion for your grade.

### Testing Types of Expressions

In test cases for type analysis,
 you write syntactically correct programs and
 mark expressions with inner square bracket blocks.
You can then specify the expected type of the marked expression in a `run x to y` clause.
For example, the following two test cases require an integer literal to be of type `Int()`
and a variable reference to be of its declared type `Bool()`:

```
module types

language minijava
start symbol Program

test integer literal type [[
  class Main {
    public static void main (String[] args) {
      System.out.println([[1]]);
    }
  }
]] run get-type on #1 to Int()

test variable reference type [[
  class Main {
    public static void main (String[] args) {
      System.out.println(new Foo().run());
    }
  }

  class Foo {
    public int run() {
      boolean x;
      int y;

      if ([[x]])
        y = 1;
      else
        y = 0;

      return y;
    }
  }
]] run get-type on #1 to Bool()
```

You can use _fixtures_ to avoid repeating parts in similar test cases. See the
[SPT documentation](https://www.metaborg.org/en/latest/source/langdev/meta/lang/spt/test-suites.html#test-fixtures)
for details.

When applying `get-type` to objects, we expect a `ClassType` constructor, which takes an
*occurrence* as an argument. Remember that an occurrence was `<Namespace>{<Name>}`, but in our test
we need to write out the constructor for it, like this:

```
test expression id type [[
  class Main {
    public static void main (String[] args) {
      System.out.println(new Foo().run());
    }
  }

  class Foo {}

  class Foobar {
    Foo x;
    public Foo method() {
      return [[x]];
    }
  }
]] run get-type on #1 to ClassType(Occurrence(_,"Foo",_))
```

Do not use the `Occurrence` constructor in your NaBL2 specification! It is partof the _internal_
representation of occurrences. In your NaBL2 rules, you should only use the special `Ns{x}` syntax.
We only use the internal constructor in tests because the special syntax is not available in SPT.
{: .notice .notice-warning}

You should come up with test cases for the types of all kinds of expressions. Just like previous
testing assignments, this assignment is all about the coverage of your test suite.

The constructors for various types are:

- Integer: `Int()`
- Boolean: `Bool()`
- Integer array: `IntArray()`
- Class with name Foo: `ClassType(Occurrence(_,"Foo",_))`

Make sure that there are no errors in tests with a `run x to y` clause. These tests are invalid when
there are errors.
{: .notice .notice-warning}

Do not use start symbols other than `Program`.
{: .notice .notice-warning}

### Testing Method Name Resolution

We did not test method names in assignment 5, since method name resolution requires type analysis.
Types are available now, so we can test method name resolution.
Consider the following test case as an example:

```
test method name resolution [[
  class Main {
    public static void main (String[] args) {
      System.out.println(new Foo().[[run]]());
    }
  }

  class Foo {
    public int [[run]]() {
      return 1;
    }
  }
]] resolve #1 to #2
```

The type of the callee expression determines the class in which the method declaration can be found.
In this example, the expression `new Foo()` is of type `ClassType(Occurrence(_,"Foo",_))` and
the corresponding class `Foo` contains a method declaration for `run()`.

You should come up with test cases for the resolution of method names.
Start with simple test cases, but keep in mind that method name resolution is quite complex
 and that coverage is the main criterion for your grade.
It is important to think about forward and backward references,
 resolution in the presence of homonyms and overriding,
 and the influence of class hierarchies on resolution.

You should also come up with test cases for error checking on method names.
This should include test cases for errors on duplicate definitions, missing definitions, and method overloading.
Similar to previous test cases, you can pair up positive (`0 errors`) and negative test cases.

Make sure that there are no errors in tests with a `resolve x to y` clause. These tests are invalid when there are errors.
{: .notice .notice-warning}

### Testing Type Error Checking

A type error occurs, when the type of an expression does not conform to its expected type.
Consider the following test case as an example:

```
test print boolean [[
  class Main {
    public static void main (String[] args) {
      System.out.println(true);
    }
  }
]] 1 error
```

In MiniJava, `System.out.println()` can only print integers.
Thus, there should be an error on `true`, when we pass it to the print statement.
Similarly, type errors can occur in other statements, expressions, and method declarations.
You should come up with test cases for such errors.
Subtyping is a common source for errors not only in programs, but also in language implementations.
It is therefore important to have positive and negative typing tests, which involve correct and incorrect subtyping.

Again, keep in mind that coverage is the main criterion for your grade.

### Number of errors

Similar to the previous testing lab, you need to be careful about the number of errors, because
errors sometimes cascade. For example, if you expect *2* errors, you should use the `>= 2 errors`
expectation, even if you expect an exact number of errors.
